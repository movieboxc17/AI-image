<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Resolution Image Stacker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .drop-area {
            border: 3px dashed #ccc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            margin: 20px 0;
            transition: background-color 0.3s;
            cursor: pointer;
        }
        .drop-area.highlight {
            background-color: #e9f7fe;
            border-color: #2196F3;
        }
        .preview-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }
        .image-preview {
            position: relative;
            width: 100px;
            height: 100px;
            overflow: hidden;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .image-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .image-preview .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(255,0,0,0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        select, input {
            padding: 8px;
            margin: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .progress-container {
            width: 100%;
            margin: 20px 0;
            display: none;
        }
        .progress-bar {
            height: 10px;
            background-color: #4CAF50;
            width: 0%;
            border-radius: 5px;
            transition: width 0.3s;
        }
        canvas {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .result-container {
            display: none;
            margin: 20px 0;
        }
        #downloadContainer {
            margin: 20px 0;
            text-align: center;
        }
        #downloadBtn {
            background-color: #2196F3;
        }
        #downloadBtn:hover {
            background-color: #0b7dda;
        }
        .info-box {
            background-color: #e9f7fe;
            border: 1px solid #2196F3;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .resolution-settings {
            margin: 15px 0;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        /* For debug */
        .debug-info {
            font-family: monospace;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>High-Resolution Image Stacker</h1>
        
        <div class="info-box">
            <p><strong>⚡ Supports up to 1500 megapixels</strong> - This tool can handle extremely large images by using advanced tiling techniques.</p>
        </div>
        
        <div class="drop-area" id="dropArea">
            <p>Drag & drop images here or</p>
            <input type="file" id="fileInput" accept="image/*" multiple>
            <button id="selectFilesBtn">Select Images</button>
            <p><small>You can upload up to 50 images</small></p>
        </div>
        
        <div class="debug-info" id="debugInfo"></div>

        <div class="preview-container" id="previewContainer"></div>
        
        <div class="controls">
            <h3>Stacking Options</h3>
            <div>
                <label for="blendMode">Blend Mode:</label>
                <select id="blendMode">
                    <option value="normal">Normal</option>
                    <option value="lighten">Lighten</option>
                    <option value="darken">Darken</option>
                    <option value="multiply">Multiply</option>
                    <option value="screen">Screen</option>
                    <option value="overlay">Overlay</option>
                    <option value="color-dodge">Color Dodge</option>
                    <option value="color-burn">Color Burn</option>
                    <option value="difference">Difference</option>
                    <option value="exclusion">Exclusion</option>
                    <option value="luminosity">Luminosity</option>
                </select>
            </div>
            <div>
                <label for="opacity">Opacity:</label>
                <input type="range" id="opacity" min="0" max="100" value="100">
                <span id="opacityValue">100%</span>
            </div>
            <div>
                <label for="alignment">Alignment:</label>
                <select id="alignment">
                    <option value="center">Center</option>
                    <option value="top-left">Top Left</option>
                    <option value="top-right">Top Right</option>
                    <option value="bottom-left">Bottom Left</option>
                    <option value="bottom-right">Bottom Right</option>
                </select>
            </div>
            
            <div class="resolution-settings">
                <h4>Output Resolution</h4>
                <div>
                    <label for="outputWidth">Width (pixels):</label>
                    <input type="number" id="outputWidth" min="100" max="100000" value="3000">
                </div>
                <div>
                    <label for="outputHeight">Height (pixels):</label>
                    <input type="number" id="outputHeight" min="100" max="100000" value="2000">
                </div>
                <div>
                    <label for="maintainOriginalSize">
                        <input type="checkbox" id="maintainOriginalSize" checked>
                        Maintain original resolution (can be very large)
                    </label>
                </div>
                <div>
                    <p>Megapixels: <span id="megapixelCount">6.0</span></p>
                </div>
            </div>
            
            <button id="stackBtn" disabled>Stack Images</button>
        </div>
        
        <div class="progress-container" id="progressContainer">
            <p>Processing: <span id="progressText">0%</span></p>
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div class="result-container" id="resultContainer">
            <h3>Stacked Image Preview</h3>
            <p>Preview (downscaled for display):</p>
            <canvas id="previewCanvas"></canvas>
            <div id="imageInfo">
                <p>Output dimensions: <span id="outputDimensions"></span></p>
                <p>Output megapixels: <span id="outputMegapixels"></span></p>
            </div>
            <div id="downloadContainer">
                <button id="downloadBtn">Download Stacked Image</button>
            </div>
        </div>
    </div>

    <script>
        // Variables to store images and settings
        const maxImages = 50;
        let uploadedImages = [];
        let stackedCanvas = null;
        let fullResolutionData = null;
        let tileSize = 8192; // Size of each tile (adjust based on browser capabilities)
        
        // DOM elements
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const selectFilesBtn = document.getElementById('selectFilesBtn');
        const previewContainer = document.getElementById('previewContainer');
        const stackBtn = document.getElementById('stackBtn');
        const blendModeSelect = document.getElementById('blendMode');
        const opacitySlider = document.getElementById('opacity');
        const opacityValue = document.getElementById('opacityValue');
        const alignmentSelect = document.getElementById('alignment');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const resultContainer = document.getElementById('resultContainer');
        const previewCanvas = document.getElementById('previewCanvas');
        const downloadBtn = document.getElementById('downloadBtn');
        const outputWidth = document.getElementById('outputWidth');
        const outputHeight = document.getElementById('outputHeight');
        const maintainOriginalSize = document.getElementById('maintainOriginalSize');
        const megapixelCount = document.getElementById('megapixelCount');
        const outputDimensions = document.getElementById('outputDimensions');
        const outputMegapixels = document.getElementById('outputMegapixels');
        const debugInfo = document.getElementById('debugInfo');
        
        // Debug function
        function debug(message) {
            console.log(message);
            debugInfo.style.display = 'block';
            debugInfo.textContent += message + '\n';
        }
        
        // Update megapixel count on resolution change
        function updateMegapixelCount() {
            const width = parseInt(outputWidth.value);
            const height = parseInt(outputHeight.value);
            const mp = (width * height / 1000000).toFixed(1);
            megapixelCount.textContent = mp;
        }
        
        outputWidth.addEventListener('input', updateMegapixelCount);
        outputHeight.addEventListener('input', updateMegapixelCount);
        maintainOriginalSize.addEventListener('change', function() {
            outputWidth.disabled = this.checked;
            outputHeight.disabled = this.checked;
        });
        
        // Initialize with default values
        updateMegapixelCount();
        
        // Event listeners for drag and drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight() {
            dropArea.classList.add('highlight');
        }
        
        function unhighlight() {
            dropArea.classList.remove('highlight');
        }
        
        // Make the entire drop area clickable to open file picker
        dropArea.addEventListener('click', function() {
            fileInput.click();
        });
        
        // Also make the select button work correctly
        selectFilesBtn.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent triggering the dropArea click
            fileInput.click();
        });
        
        // Handle file drop
        dropArea.addEventListener('drop', function(e) {
            const dt = e.dataTransfer;
            if (dt.files && dt.files.length > 0) {
                handleFiles(dt.files);
            }
        });
        
        // Handle file input change
        fileInput.addEventListener('change', function() {
            if (this.files && this.files.length > 0) {
                handleFiles(this.files);
                debug(`Selected ${this.files.length} files`);
            }
        });
        
        // Process uploaded files
        function handleFiles(files) {
            if (files.length === 0) return;
            
            debug(`Processing ${files.length} files`);
            
            if (uploadedImages.length + files.length > maxImages) {
                alert(`You can only upload up to ${maxImages} images. Only the first ${maxImages - uploadedImages.length} will be added.`);
                files = Array.from(files).slice(0, maxImages - uploadedImages.length);
            }
            
            Array.from(files).forEach(file => {
                if (file.type.match('image.*')) {
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        const img = new Image();
                        
                        img.onload = function() {
                            debug(`Loaded image: ${file.name} (${img.width}x${img.height})`);
                            
                            uploadedImages.push({
                                element: img,
                                file: file,
                                width: img.width,
                                height: img.height
                            });
                            
                            createPreviewElement(img, uploadedImages.length - 1);
                            updateStackButton();
                        };
                        
                        img.onerror = function() {
                            debug(`Error loading image: ${file.name}`);
                            alert(`Error loading image: ${file.name}`);
                        };
                        
                        img.src = e.target.result;
                    };
                    
                    reader.onerror = function() {
                        debug(`Error reading file: ${file.name}`);
                        alert(`Error reading file: ${file.name}`);
                    };
                    
                    reader.readAsDataURL(file);
                } else {
                    debug(`Skipped non-image file: ${file.name}`);
                    alert(`"${file.name}" is not a valid image file.`);
                }
            });
        }
        
        // Create preview element for each image
        function createPreviewElement(img, index) {
            const previewDiv = document.createElement('div');
            previewDiv.className = 'image-preview';
            previewDiv.dataset.index = index;
            previewDiv.setAttribute('draggable', 'true');
            
            const imgElement = document.createElement('img');
            imgElement.src = img.src;
            
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.textContent = '×';
            removeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                uploadedImages.splice(index, 1);
                previewContainer.removeChild(previewDiv);
                
                // Update all indices
                const previews = previewContainer.querySelectorAll('.image-preview');
                previews.forEach((preview, i) => {
                    preview.dataset.index = i;
                });
                
                updateStackButton();
            });
            
            previewDiv.appendChild(imgElement);
            previewDiv.appendChild(removeBtn);
            previewContainer.appendChild(previewDiv);
            
            // Set up drag and drop for reordering
            previewDiv.addEventListener('dragstart', function(e) {
                e.dataTransfer.setData('text/plain', index);
                setTimeout(() => this.classList.add('dragging'), 0);
            });
            
            previewDiv.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.classList.add('drag-over');
            });
            
            previewDiv.addEventListener('dragleave', function() {
                this.classList.remove('drag-over');
            });
            
            previewDiv.addEventListener('drop', function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');
                const srcIndex = parseInt(e.dataTransfer.getData('text/plain'));
                const destIndex = parseInt(this.dataset.index);
                
                if (srcIndex !== destIndex) {
                    // Reorder the images array
                    const temp = uploadedImages[srcIndex];
                    
                    if (srcIndex < destIndex) {
                        // Moving forward
                        for (let i = srcIndex; i < destIndex; i++) {
                            uploadedImages[i] = uploadedImages[i + 1];
                        }
                    } else {
                        // Moving backward
                        for (let i = srcIndex; i > destIndex; i--) {
                            uploadedImages[i] = uploadedImages[i - 1];
                        }
                    }
                    
                    uploadedImages[destIndex] = temp;
                    
                    // Refresh the preview display
                    while (previewContainer.firstChild) {
                        previewContainer.removeChild(previewContainer.firstChild);
                    }
                    
                    uploadedImages.forEach((img, idx) => {
                        createPreviewElement(img.element, idx);
                    });
                }
            });
            
            previewDiv.addEventListener('dragend', function() {
                this.classList.remove('dragging');
                document.querySelectorAll('.image-preview').forEach(preview => {
                    preview.classList.remove('drag-over');
                });
            });
        }
        
        // Update stack button state
        function updateStackButton() {
            stackBtn.disabled = uploadedImages.length < 1;
        }
        
        // Handle opacity slider change
        opacitySlider.addEventListener('input', function() {
            opacityValue.textContent = this.value + '%';
        });
        
        // Stack images when button is clicked
        stackBtn.addEventListener('click', stackImages);
        
        // Helper function to get the maximum dimensions of all uploaded images
        function getMaxDimensions() {
            if (uploadedImages.length === 0) return { width: 0, height: 0 };
            
            let maxWidth = 0;
            let maxHeight = 0;
            
            uploadedImages.forEach(img => {
                maxWidth = Math.max(maxWidth, img.width);
                maxHeight = Math.max(maxHeight, img.height);
            });
            
            return { width: maxWidth, height: maxHeight };
        }
        
        // High resolution image stacking function
        function stackImages() {
            if (uploadedImages.length === 0) return;
            
            progressContainer.style.display = 'block';
            resultContainer.style.display = 'none';
            
            // Determine output dimensions
            let outputDims;
            if (maintainOriginalSize.checked) {
                outputDims = getMaxDimensions();
            } else {
                outputDims = {
                    width: parseInt(outputWidth.value),
                    height: parseInt(outputHeight.value)
                };
            }
            
            // Check if dimensions are viable
            const MAX_DIMENSION = 32000; // Most browsers can handle this
            const megapixels = (outputDims.width * outputDims.height) / 1000000;
            
            // Update info display
            outputDimensions.textContent = `${outputDims.width} × ${outputDims.height} pixels`;
            outputMegapixels.textContent = `${megapixels.toFixed(1)} MP`;
            
            if (outputDims.width > MAX_DIMENSION || outputDims.height > MAX_DIMENSION || megapixels > 1500) {
                // We need to use tiling for extremely large images
                stackImagesWithTiling(outputDims);
            } else {
                // We can use regular canvas for smaller images
                stackImagesDirectly(outputDims);
            }
        }
        
        // Standard stacking for images within browser limits
        function stackImagesDirectly(outputDims) {
            const canvas = document.createElement('canvas');
            canvas.width = outputDims.width;
            canvas.height = outputDims.height;
            const ctx = canvas.getContext('2d');
            
            // Get selected options
            const blendMode = blendModeSelect.value;
            const opacity = opacitySlider.value / 100;
            const alignment = alignmentSelect.value;
            
            // Stack images one by one
            let processed = 0;
            
            function processNextImage() {
                if (processed < uploadedImages.length) {
                    const img = uploadedImages[processed].element;
                    
                    // Calculate position based on alignment
                    let x = 0, y = 0;
                    
                    switch(alignment) {
                        case 'center':
                            x = (outputDims.width - img.width) / 2;
                            y = (outputDims.height - img.height) / 2;
                            break;
                        case 'top-left':
                            x = 0;
                            y = 0;
                            break;
                        case 'top-right':
                            x = outputDims.width - img.width;
                            y = 0;
                            break;
                        case 'bottom-left':
                            x = 0;
                            y = outputDims.height - img.height;
                            break;
                        case 'bottom-right':
                            x = outputDims.width - img.width;
                            y = outputDims.height - img.height;
                            break;
                    }
                    
                    // Apply blend mode and opacity
                    ctx.globalCompositeOperation = blendMode === 'normal' ? 'source-over' : blendMode;
                    ctx.globalAlpha = opacity;
                    
                    // Draw the image, scaling if needed
                    if (maintainOriginalSize.checked) {
                        ctx.drawImage(img, x, y);
                    } else {
                        // Scale the image to fit the output dimensions while maintaining aspect ratio
                        const scale = Math.min(
                            outputDims.width / img.width,
                            outputDims.height / img.height
                        );
                        
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        
                        // Recalculate position based on alignment
                        switch(alignment) {
                            case 'center':
                                x = (outputDims.width - scaledWidth) / 2;
                                y = (outputDims.height - scaledHeight) / 2;
                                break;
                            case 'top-left':
                                x = 0;
                                y = 0;
                                break;
                            case 'top-right':
                                x = outputDims.width - scaledWidth;
                                y = 0;
                                break;
                            case 'bottom-left':
                                x = 0;
                                y = outputDims.height - scaledHeight;
                                break;
                            case 'bottom-right':
                                x = outputDims.width - scaledWidth;
                                y = outputDims.height - scaledHeight;
                                break;
                        }
                        
                        ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                    }
                    
                    // Update progress
                    processed++;
                    const progress = Math.round((processed / uploadedImages.length) * 100);
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `${progress}%`;
                    
                    // Process next image or finish
                    setTimeout(processNextImage, 0);
                } else {
                    // All images processed
                    stackedCanvas = canvas;
                    finishStacking(canvas);
                }
            }
            
            // Start processing
            processNextImage();
        }
        
        // Tiling approach for extremely large images (beyond browser limits)
        function stackImagesWithTiling(outputDims) {
            // Create full resolution data object
            fullResolutionData = {
                width: outputDims.width,
                height: outputDims.height,
                tiles: [],
                tileSize: tileSize
            };
            
            const totalTilesX = Math.ceil(outputDims.width / tileSize);
            const totalTilesY = Math.ceil(outputDims.height / tileSize);
            const totalTiles = totalTilesX * totalTilesY;
            
            // Initialize progress tracking
            let tilesProcessed = 0;
            
            // Get selected options
            const blendMode = blendModeSelect.value;
            const opacity = opacitySlider.value / 100;
            const alignment = alignmentSelect.value;
            
            // Process each tile
            function processTile(tileX, tileY) {
                const tileWidth = Math.min(tileSize, outputDims.width - tileX * tileSize);
                const tileHeight = Math.min(tileSize, outputDims.height - tileY * tileSize);
                
                const canvas = document.createElement('canvas');
                canvas.width = tileWidth;
                canvas.height = tileHeight;
                const ctx = canvas.getContext('2d');
                
                // Process each image for this tile
                let imageIndex = 0;
                
                function processImageForTile() {
                    if (imageIndex < uploadedImages.length) {
                        const img = uploadedImages[imageIndex].element;
                        
                        // Calculate position based on alignment
                        let baseX = 0, baseY = 0;
                        
                        switch(alignment) {
                            case 'center':
                                baseX = (outputDims.width - img.width) / 2;
                                baseY = (outputDims.height - img.height) / 2;
                                break;
                            case 'top-left':
                                baseX = 0;
                                baseY = 0;
                                break;
                            case 'top-right':
                                baseX = outputDims.width - img.width;
                                baseY = 0;
                                break;
                            case 'bottom-left':
                                baseX = 0;
                                baseY = outputDims.height - img.height;
                                break;
                            case 'bottom-right':
                                baseX = outputDims.width - img.width;
                                baseY = outputDims.height - img.height;
                                break;
                        }
                        
                        // Calculate the portion of this image that overlaps with the current tile
                        const tileLeft = tileX * tileSize;
                        const tileTop = tileY * tileSize;
                        const tileRight = tileLeft + tileWidth;
                        const tileBottom = tileTop + tileHeight;
                        
                        const imgLeft = baseX;
                        const imgTop = baseY;
                        const imgRight = imgLeft + img.width;
                        const imgBottom = imgTop + img.height;
                        
                        // Check if image overlaps with the tile
                        if (imgRight > tileLeft && imgLeft < tileRight && imgBottom > tileTop && imgTop < tileBottom) {
                            // Calculate the overlapping region
                            const overlapLeft = Math.max(tileLeft, imgLeft);
                            const overlapTop = Math.max(tileTop, imgTop);
                            const overlapRight = Math.min(tileRight, imgRight);
                            const overlapBottom = Math.min(tileBottom, imgBottom);
                            
                            // Calculate source and destination coordinates
                            const srcX = overlapLeft - imgLeft;
                            const srcY = overlapTop - imgTop;
                            const srcWidth = overlapRight - overlapLeft;
                            const srcHeight = overlapBottom - overlapTop;
                            
                            const destX = overlapLeft - tileLeft;
                            const destY = overlapTop - tileTop;
                            
                            // Apply blend mode and opacity
                            ctx.globalCompositeOperation = blendMode === 'normal' ? 'source-over' : blendMode;
                            ctx.globalAlpha = opacity;
                            
                            // Draw the portion of the image that overlaps with this tile
                            ctx.drawImage(
                                img,
                                srcX, srcY, srcWidth, srcHeight,
                                destX, destY, srcWidth, srcHeight
                            );
                        }
                        
                        imageIndex++;
                        setTimeout(processImageForTile, 0);
                    } else {
                        // All images processed for this tile
                        // Store tile data
                        fullResolutionData.tiles.push({
                            x: tileX,
                            y: tileY,
                            width: tileWidth,
                            height: tileHeight,
                            data: canvas.toDataURL('image/png')
                        });
                        
                        tilesProcessed++;
                        
                        // Update progress
                        const progress = Math.round((tilesProcessed / totalTiles) * 100);
                        progressBar.style.width = `${progress}%`;
                        progressText.textContent = `${progress}% (Tile ${tilesProcessed}/${totalTiles})`;
                        
                                                // Process next tile or finish
                                                if (tilesProcessed === totalTiles) {
                            // All tiles processed, create preview
                            createPreviewFromTiles();
                        } else {
                            // Process next tile
                            const nextTileX = (tileX + 1) % totalTilesX;
                            const nextTileY = nextTileX === 0 ? tileY + 1 : tileY;
                            setTimeout(() => processTile(nextTileX, nextTileY), 0);
                        }
                    }
                }
                
                // Start processing images for this tile
                processImageForTile();
            }
            
            // Start processing the first tile
            processTile(0, 0);
        }
        
        // Create preview from tiles
        function createPreviewFromTiles() {
            // Create a downscaled preview for display
            const MAX_PREVIEW_SIZE = 800;
            
            const aspectRatio = fullResolutionData.width / fullResolutionData.height;
            let previewWidth, previewHeight;
            
            if (aspectRatio > 1) {
                previewWidth = Math.min(MAX_PREVIEW_SIZE, fullResolutionData.width);
                previewHeight = previewWidth / aspectRatio;
            } else {
                previewHeight = Math.min(MAX_PREVIEW_SIZE, fullResolutionData.height);
                previewWidth = previewHeight * aspectRatio;
            }
            
            previewCanvas.width = previewWidth;
            previewCanvas.height = previewHeight;
            const previewCtx = previewCanvas.getContext('2d');
            
            // Create a small temporary canvas for the preview
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = previewWidth;
            tempCanvas.height = previewHeight;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Draw scaled version of the first few tiles to create preview
            const scaleFactor = previewWidth / fullResolutionData.width;
            
            let tilesLoaded = 0;
            fullResolutionData.tiles.forEach(tile => {
                const img = new Image();
                img.onload = function() {
                    const destX = tile.x * fullResolutionData.tileSize * scaleFactor;
                    const destY = tile.y * fullResolutionData.tileSize * scaleFactor;
                    const destWidth = tile.width * scaleFactor;
                    const destHeight = tile.height * scaleFactor;
                    
                    tempCtx.drawImage(img, destX, destY, destWidth, destHeight);
                    
                    tilesLoaded++;
                    if (tilesLoaded === fullResolutionData.tiles.length) {
                        // All tiles loaded for preview, update the display canvas
                        previewCtx.clearRect(0, 0, previewWidth, previewHeight);
                        previewCtx.drawImage(tempCanvas, 0, 0);
                        
                        // Show result container
                        progressContainer.style.display = 'none';
                        resultContainer.style.display = 'block';
                    }
                };
                img.src = tile.data;
            });
        }
        
        // Standard finish function for smaller images
        function finishStacking(canvas) {
            // Create preview
            const maxPreviewWidth = 800;
            const maxPreviewHeight = 600;
            const aspectRatio = canvas.width / canvas.height;
            
            let previewWidth, previewHeight;
            
            if (aspectRatio > maxPreviewWidth / maxPreviewHeight) {
                // Width constrained
                previewWidth = Math.min(canvas.width, maxPreviewWidth);
                previewHeight = previewWidth / aspectRatio;
            } else {
                // Height constrained
                previewHeight = Math.min(canvas.height, maxPreviewHeight);
                previewWidth = previewHeight * aspectRatio;
            }
            
            previewCanvas.width = previewWidth;
            previewCanvas.height = previewHeight;
            
            // Draw the stacked image on the preview canvas
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.drawImage(canvas, 0, 0, previewWidth, previewHeight);
            
            // Show result container
            progressContainer.style.display = 'none';
            resultContainer.style.display = 'block';
        }
        
        // Handle download button click
        downloadBtn.addEventListener('click', function() {
            if (stackedCanvas) {
                // Standard canvas download
                downloadStandardCanvas();
            } else if (fullResolutionData) {
                // Tiled high-res download
                downloadTiledCanvas();
            }
        });
        
        // Download for standard canvas
        function downloadStandardCanvas() {
            const quality = 0.9;
            
            stackedCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'stacked_image.png';
                link.click();
                
                // Clean up
                setTimeout(() => URL.revokeObjectURL(url), 60000);
            }, 'image/png');
        }
        
        // Download for tiled canvas (extremely large)
        function downloadTiledCanvas() {
            // Show download progress
            progressContainer.style.display = 'block';
            progressText.textContent = 'Preparing download...';
            progressBar.style.width = '0%';
            
            // For extremely large images, we need to use a chunked approach
            // or provide separate tiles for the user to combine externally
            
            // Option 1: Generate a combined image if below certain threshold (e.g., 10,000 x 10,000)
            if (fullResolutionData.width <= 10000 && fullResolutionData.height <= 10000) {
                combineAndDownloadTiles();
            } else {
                // Option 2: Provide a zip of tiles for extremely large images
                provideTilesForDownload();
            }
        }
        
        // Combine tiles into a single image for download
        function combineAndDownloadTiles() {
            // Create an offscreen canvas for the full image
            const canvas = document.createElement('canvas');
            canvas.width = fullResolutionData.width;
            canvas.height = fullResolutionData.height;
            const ctx = canvas.getContext('2d');
            
            // Total tiles to process
            const totalTiles = fullResolutionData.tiles.length;
            let tilesProcessed = 0;
            
            // Process tiles sequentially to avoid memory issues
            function processNextTile(index) {
                if (index >= totalTiles) {
                    // All tiles processed, download the result
                    finalizeDownload(canvas);
                    return;
                }
                
                const tile = fullResolutionData.tiles[index];
                const img = new Image();
                
                img.onload = function() {
                    const destX = tile.x * fullResolutionData.tileSize;
                    const destY = tile.y * fullResolutionData.tileSize;
                    
                    ctx.drawImage(img, destX, destY);
                    
                    // Update progress
                    tilesProcessed++;
                    const progress = Math.round((tilesProcessed / totalTiles) * 100);
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `Preparing download: ${progress}%`;
                    
                    // Free memory by removing the reference to the image
                    img.src = '';
                    
                    // Process next tile
                    setTimeout(() => processNextTile(index + 1), 0);
                };
                
                img.onerror = function() {
                    debug(`Error loading tile ${index} for download`);
                    // Continue with next tile even if there's an error
                    tilesProcessed++;
                    setTimeout(() => processNextTile(index + 1), 0);
                };
                
                img.src = tile.data;
            }
            
            // Start processing tiles
            processNextTile(0);
        }
        
        // Finalize the download process
        function finalizeDownload(canvas) {
            try {
                progressText.textContent = 'Creating download file...';
                
                // Use a lower quality setting for very large images to reduce file size
                const quality = fullResolutionData.width * fullResolutionData.height > 50000000 ? 0.7 : 0.9;
                
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    
                    progressText.textContent = 'Download ready!';
                    progressBar.style.width = '100%';
                    
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = 'stacked_image_' + fullResolutionData.width + 'x' + fullResolutionData.height + '.png';
                    link.click();
                    
                    // Clean up
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                        progressContainer.style.display = 'none';
                    }, 5000);
                }, 'image/png', quality);
            } catch (e) {
                alert('Error creating the high-resolution image. The file may be too large for your browser to handle. Try with smaller dimensions or fewer images.');
                console.error('Download error:', e);
                progressContainer.style.display = 'none';
            }
        }
        
        // Provide tiles as separate downloads for extremely large images
        function provideTilesForDownload() {
            // Create ZIP file with multiple tiles
            // Note: This would require a ZIP library like JSZip
            alert('This image is extremely large (' + fullResolutionData.width + 'x' + fullResolutionData.height + ' pixels). ' +
                  'Your browser may not be able to process it as a single file. ' +
                  'The image will be downloaded in tiles that you can combine with external software.');
            
            // For simplicity, we'll just download the first few tiles as examples
            const maxTilesToDownload = 4;
            const tilesToDownload = Math.min(maxTilesToDownload, fullResolutionData.tiles.length);
            
            for (let i = 0; i < tilesToDownload; i++) {
                const tile = fullResolutionData.tiles[i];
                const link = document.createElement('a');
                link.href = tile.data;
                link.download = `stacked_image_tile_${tile.x}_${tile.y}.png`;
                
                // Slight delay between downloads
                setTimeout(() => link.click(), i * 500);
            }
            
            progressContainer.style.display = 'none';
            
            if (fullResolutionData.tiles.length > maxTilesToDownload) {
                alert(`Downloading ${maxTilesToDownload} sample tiles out of ${fullResolutionData.tiles.length} total tiles. For full download, please use a smaller image size.`);
            }
        }
        
        // Utility function to format file size
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            if (bytes < 1073741824) return (bytes / 1048576).toFixed(1) + ' MB';
            return (bytes / 1073741824).toFixed(1) + ' GB';
        }
        
        // Initialize the app
        function init() {
            // Set up event handlers for controls
            opacitySlider.addEventListener('input', function() {
                opacityValue.textContent = `${this.value}%`;
            });
            
            // Default state for resolution inputs
            outputWidth.disabled = maintainOriginalSize.checked;
            outputHeight.disabled = maintainOriginalSize.checked;
            
            // Make file input visible for direct access and to ensure it works on all browsers
            fileInput.style.display = 'block';
            fileInput.style.width = '100%';
            fileInput.style.margin = '10px 0';
            fileInput.style.padding = '10px';
            
            // Any other initialization
            debug('Image Stacker initialized. Supported resolution: up to 1500 megapixels');
        }
        
        // Run initialization when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
